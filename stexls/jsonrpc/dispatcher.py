from __future__ import annotations

import asyncio
import itertools
import logging
import os
import sys
from typing import Any, Awaitable, Dict, List, Literal, Optional, Tuple, Union

from .connection import JsonRpcConnection
from .core import NotificationObject, RequestObject
from .hooks import extract_methods
from .streams import JsonStream

log = logging.getLogger(__name__)

__all__ = ['Dispatcher']


class Dispatcher:
    ''' A dispatcher is a hook that allows sending user messages to a connection
        between a client and the server.
        The dispatcher behaves like a normal python object, except that
        the called methods are done somewhere different and have to wait
        until the message is send, handled and the response returned.
    '''

    def __init__(self, connection: JsonRpcConnection, *args, **kwargs):
        """Initializes the given connection protocol.

        Initialization is done by simply registering all @method hooks with the json-rpc connection.
        The connection is stored and used by @request and @notification hooks in order to
        delegate these calls to the connection.

        Args:
            connection (JsonRpcConnection): Target connection to delegate method calls to,
                and provide method handlers for.
        """
        self.connection = connection
        self.__request_id_generator = itertools.count(1)
        for name, callback in extract_methods(self).items():
            connection.on(name, callback)

    def request(self, method: str, params: Optional[Union[List[Any], Tuple[Any, ...], Dict[str, Any]]] = None) -> Awaitable[Any]:
        """ Sends a request message.

        The id for the request will be automatically generated by incrementing, starting from 1.

        Args:
            method (str): Method name to request.
            params (Union[list, dict, None], optional): Valid json-rpc parameter object. Defaults to None.

        Returns:
            Awaitable: Future with the value of the remote method.
        """
        id = next(self.__request_id_generator)
        log.debug('Dispatching request %s(%s) with id %i.', method, params, id)
        message = RequestObject(id, method, params)
        return self.connection.send_request(message)

    def notification(self, method: str, params: Optional[Union[List[Any], Tuple[Any, ...], Dict[str, Any]]] = None) -> Awaitable[None]:
        """ Sends a notification.

        Args:
            method (str): Remote method name.
            params (Union[list, dict, None], optional): Valid json-rpc parameters. Defaults to None.

        Returns:
            Dummy awaitable so that the caller can yield and let the server send the notification.
        """
        log.debug('Dispatching notification %s(%s).', method, params)
        message = NotificationObject(method, params)
        self.connection.send_notification(message)
        return asyncio.sleep(0)

    @ classmethod
    async def start_server(
            dispatcher_factory,
            host: str = 'localhost',
            port: int = 0,
            *args,
            encoding: str = 'utf-8',
            charset: str = None,
            newline: str = '\r\n',
            **kwargs) -> Tuple[Tuple[str, int], asyncio.Task[None]]:
        """ Starts a tcp server.

        Args:
            dispatcher_factory: A Dispatcher type.
            host: Host name to connect to.
            port: Port to connect to.
            encoding: Encoding of the sent binary data.
            charset: Optional encoding of the sent contents. Uses encoding if None.
            newline: Which character terminates lines.

        Returns:
            Tuple[Tuple[str, int], asyncio.Task]: Returns a tuple of host name and port the
                server is running on, as well as the asyncio task the server runs on.
                The task can be canceled to stop the server.
        """
        def connect_fun(r, w):
            peername = w.get_extra_info('peername')
            log.info('Incoming connection from %s', peername)
            stream = JsonStream(
                r, w, encoding=encoding, charset=charset, newline=newline)
            conn = JsonRpcConnection(stream)
            _ = dispatcher_factory(conn, *args, **kwargs)
            asyncio.create_task(conn.run_forever())
        server = await asyncio.start_server(connect_fun, host=host, port=port)

        async def task():
            async with server:
                await server.serve_forever()
        assert server.sockets is not None
        server_name: Tuple[str, int] = server.sockets[0].getsockname()[:2]
        server_task: asyncio.Task[None] = asyncio.create_task(task())
        return server_name, server_task

    @ classmethod
    async def open_connection(
            dispatcher_factory,
            host: str = 'localhost',
            port: int = 0,
            *args,
            encoding: str = 'utf-8',
            charset: str = None,
            newline: str = '\r\n',
            **kwargs) -> Tuple[Dispatcher, asyncio.Task]:
        """ Opens a connection to a tcp server.

        Parameters:
            dispatcher_factory: A Dispatcher type.
            host: Host name to connect to.
            port: Port to connect to.
            encoding: Encoding of the sent binary data.
            charset: Optional encoding of the sent contents.
            newline: Which character terminates lines.

        Keyword Parameters:
            The variadic keyword parameters are forwarded to the dispatcher_factory call.

        Returns:
            Tuple[Dispatcher, asyncio.Task]: Returns the dispatcher instance for this connection
                as well as the task which runs the client's event loop.
        """
        reader, writer = await asyncio.open_connection(host=host, port=port)
        stream = JsonStream(
            reader, writer, encoding=encoding, charset=charset, newline=newline)
        conn = JsonRpcConnection(stream)
        conn_task = asyncio.create_task(conn.run_forever())
        dispatcher = dispatcher_factory(conn, *args, **kwargs)
        return dispatcher, conn_task

    @ classmethod
    async def open_ipc_connection(
            dispatcher_factory,
            input_fd: Union[
                int, Literal['stdin', 'stdout', 'stderr']] = 'stdin',
            output_fd: Union[
                int, Literal['stdout', 'stdout', 'stderr']] = 'stdout',
            *args,
            encoding: str = 'utf-8',
            charset: str = None,
            newline: str = '\r\n',
            loop=None,
            **kwargs) -> Tuple[Dispatcher, asyncio.Task]:
        """ Opens connection using a pipe or file.

        Takes input and output file descriptors and uses
        them as the streams for the json connection.

        Parameters:
            dispatcher_factory: A Dispatcher type.
            input_fd: Input file descriptor of pipe.
                Can also be a string of "stdin".
            output_fd: Output file descriptor of pipe.
                Can also be a string of "stdout" or "stderr".
            encoding: Encoding of the sent binary data.
            charset: Optional encoding of the sent contents.
            newline: Which character terminates lines.
            loop: Asyncio event loop.

        Keyword Parameters:
            The keyword parameters are forwarded to the dispatcher_factory call.

        Returns:
            Tuple[Dispatcher, asyncio.Task]: Returns the dispatcher for the connection
                as well as the task the protocol runs on.
        """
        translate: Dict[str, int] = {
            'stdin': sys.stdin.fileno(),
            'stdout': sys.stdout.fileno(),
            'stderr': sys.stderr.fileno(),
        }
        if isinstance(input_fd, str):
            input_fd = translate[input_fd]
        if isinstance(output_fd, str):
            output_fd = translate[output_fd]
        input_pipe = os.fdopen(input_fd, 'rb', 0)
        output_pipe = os.fdopen(output_fd, 'wb', 0)
        loop = loop or asyncio.get_event_loop()
        reader = asyncio.StreamReader(loop=loop)
        await loop.connect_read_pipe(
            lambda: asyncio.StreamReaderProtocol(reader, loop=loop), input_pipe)
        writer_transport, writer_protocol = await loop.connect_write_pipe(
            lambda: asyncio.streams.FlowControlMixin(
                loop=loop),  # type: ignore
            output_pipe)
        writer = asyncio.streams.StreamWriter(
            writer_transport, writer_protocol, None, loop)
        stream = JsonStream(
            reader, writer, encoding=encoding, charset=charset, newline=newline)
        conn = JsonRpcConnection(stream)
        conn_task = asyncio.create_task(conn.run_forever())
        dispatcher = dispatcher_factory(conn, *args, **kwargs)
        return dispatcher, conn_task
